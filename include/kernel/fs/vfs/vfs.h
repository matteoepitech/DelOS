/*
** DELOS PROJECT, 2025
** include/kernel/fs/vfs
** File description:
** VFS header file
*/

#include <kernel/fs/vfs/vfs_stat.h>
#include <defines.h>
#include <types.h>

#ifndef KERNEL_FS_VFS_H_
    #define KERNEL_FS_VFS_H_

    #ifndef KVFS_MAX_FS_NAME_LEN
        #define KVFS_MAX_FS_NAME_LEN 8
    #endif /* ifndef KVFS_MAX_FS_NAME_LEN */

    #ifndef KVFS_MAX_PATH_PARTS
        #define KVFS_MAX_PATH_PARTS 16
    #endif /* ifndef KVFS_MAX_PATH_PARTS */

    #ifndef KVFS_MAX_NAME_LEN
        #define KVFS_MAX_NAME_LEN 255
    #endif /* ifndef KVFS_MAX_NAME_LEN */

/*
 * @brief Structure for a VFS node which is a file object in memory for file, dir, link, ...
 *        - type     = the type of the node (file, dir, symlink, device)
 *        - size     = the size in bytes of the file
 *        - refcount = the number of reference for a file before closing or deleting it (depends on case usage)
 *        - ops      = the function pointers (callback) for the differents actions of the specified fs
 *        - fs       = pointer to the fs driver used by this node (not an instance)
 *        - private  = the pointer to something we don't know (used by the fs drivers)
 */
typedef struct vfs_node_s {
    uint32_t _refcount;
    struct vfs_ops_s *_ops;
    struct vfs_fs_s *_fs;
    void *_private;
} vfs_node_t;

/*
 * @brief Structure for a VFS file system.
 *        - name  = the name of the filesystem in a string "ext2", "tar", "fat32"
 *        - mount = the function pointer to the mount callback
 */
typedef struct vfs_fs_s {
    const char _name[KVFS_MAX_FS_NAME_LEN];
    vfs_node_t *(*_mount)(const char *loc, void *device);
} vfs_fs_t;

/*
 * @brief Structure for a VFS mount of a file system.
 *        - mount_location = the location in a string of where the fs is mounted
 *        - fs             = pointer to the fs driver used by this mount (not an instance)
 *        - root           = the node of the root directory/file of that fs
 */
typedef struct vfs_mount_s {
    char _mount_location[KVFS_MAX_NAME_LEN];
    vfs_fs_t *_fs;
    vfs_node_t *_root;
} vfs_mount_t;

/* @brief This prevent to include vfs_dir.h which will make infinite inclusion */
struct vfs_dirent_s;

/* @brief This prevent to include vfs_stat.h */
struct vfs_stat_s;

/*
 * @brief Structure for all VFS operations like open, read, write.
 *        This is using for callback implementations for differentes file system.
 *        - read    = the function pointer to read data from the node
 *        - write   = the function pointer to write data from the node
 *        - lookup  = the function pointer to get another node from a node
 *        - create  = the function pointer to create a file in a parent node
 *        - mkdir   = the function pointer to create a dir in a parent node
 *        - rmdir   = the function pointer to remove a directory within a parent
 *        - readdir = the function pointer to iterate through a directory VFS struct
 *        - unlink  = the function pointer to unlink a file whithin a parent
 */
typedef struct vfs_ops_s {
    size_t (*_read)(vfs_node_t *node, off_t offset, void *buffer, size_t len);
    size_t (*_write)(vfs_node_t *node, off_t offset, const void *buffer, size_t len);
    vfs_node_t *(*_lookup)(vfs_node_t *node, const char *next_level);
    bool32_t (*_create)(vfs_node_t *parent, const char *name);
    bool32_t (*_mkdir)(vfs_node_t *parent, const char *name);
    bool32_t (*_rmdir)(vfs_node_t *dir);
    bool32_t (*_readdir)(vfs_node_t *dir, uint32_t index, struct vfs_dirent_s *dirent);
    bool32_t (*_unlink)(vfs_node_t *node);
    bool32_t (*_stat)(vfs_node_t *node, struct vfs_stat_s *stat_ptr);
} vfs_ops_t;

/* @brief Variable that contain the pointer to the VFS node of the root directory obtained by mouting the VFS */
extern vfs_node_t *kvfs_root_mount_dir;
/* @brief Variable for kernel space "current working directory" (should be root at start time) */
extern vfs_node_t *kvfs_cwd ;

/**
 * @brief Mount a filesystem in our VFS architecture.
 *
 * @param fs_name    The name of the file system (need to be exact)
 * @param location   Where to locate that mounting
 * @param device     The device pointer on how to access data
 *
 * @return The VFS node of the root of that mounting.
 */
vfs_node_t *
kvfs_mount(const char *fs_name, const char *location, void *device);

/**
 * @brief Lookup a node and try to find another level.
 *
 * @param node           The current node to go through (a dir for example)
 * @param next_level     The next level to lookup (e.g. node = "/", nextlevel = "abc", result = "/abc")
 *
 * @return The new node generated by the lookup callback.
 */
vfs_node_t *
kvfs_lookup(vfs_node_t *node, const char *next_level);

/**
 * @brief Create a file in a parent node.
 *
 * @param parent     The parent of the file (likely a dir)
 * @param name       The name of the file we want to create
 *
 * @return OK_TRUE if worked, KO_FALSE otherwise.
 */
bool32_t
kvfs_create(vfs_node_t *parent, const char *name);

/**
 * @brief Create a directory in a parent node.
 *
 * @param parent     The parent of the directory (likely a dir)
 * @param name       The name of the directory we want to mkdir
 *
 * @return OK_TRUE if worked, KO_FALSE otherwise.
 */
bool32_t
kvfs_mkdir(vfs_node_t *parent, const char *name);

/**
 * @brief Remove a directory at a given path.
 *
 * @param path   The path of the directory to remove
 *
 * @return OK_TRUE if worked, KO_FALSE otherwise.
 */
bool32_t
kvfs_rmdir(const char *path);

/**
 * @brief Write some data in a file.
 *
 * @param node       The node where to write the data
 * @param buffer     The buffer to take the data from
 * @param len        Number of maximum byte to write
 *
 * @return Number of bytes write on the file.
 */
size_t
kvfs_write(vfs_node_t *node, const void *buffer, size_t len);

/**
 * @brief Read some data from a file.
 *
 * @param node       The node where to read the data
 * @param buffer     The buffer to put the data
 * @param len        Number of maximum byte to read
 *
 * @return Number of bytes read on the file.
 */
size_t
kvfs_read(vfs_node_t *node, void *buffer, size_t len);

/**
 * @brief Unlink a node (remove it's entry but not his data of course)
 *
 * @param path   The path to the file to unlink
 *
 * @return OK_TRUE if worked, KO_FALSE otherwise.
 */
bool32_t
kvfs_unlink(const char *path);

/**
 * @brief Get metadata using the stat structure of a file or directory or such.
 *
 * @param path       The path of the file to get stat from
 * @param stat_ptr   The pointer to the stat buffer
 *
 * @return OK_TRUE if worked, KO_FALSE otherwise.
 */
bool32_t
kvfs_stat(const char *path, struct vfs_stat_s *stat_ptr);

/**
 * @brief Open a file and go through its entire path to get the node associated to the end level.
 *
 * @param path   The complete path to a node (e.g. "/abc/dir/a.txt")
 *
 * @return The VFS node of the path result. (Can be anything: file, dir, link, ...)
 */
vfs_node_t *
kvfs_open(const char *path);

/**
 * @brief Resolve and get the VFS node of a relative path using the start.
 *
 * @param start  The start of the resolving, NULL for root
 * @param path   The relative path to a node from the start (e.g. "abc/dir/a.txt")
 *
 * @return The VFS node of the path result. (Can be anything: file, dir, link, ...)
 */
vfs_node_t *
kvfs_resolve_from(vfs_node_t *start, const char *path);

/**
 * @brief Close a VFS node, if the refcount is zeroed then destroying it.
 *
 * @param node   The VFS node to close
 */
void
kvfs_close(vfs_node_t *node);

/**
 * @brief Give us the pointer to the literal string of a type node name.
 *
 * @param mode   The mode of the entry
 *
 * @return The pointer to the literal string 
 */
char *
kvfs_get_type_string(mode_t mode);

/**
 * @brief Split an entire path into some tokens for easier parsing.
 *
 * @param path           The path to split
 * @param tokens         The buffer of tokens (need to be pre-allocated)
 *
 * @return Number of part got.
 */
size_t
kvfs_split_path(const char *path, char tokens[KVFS_MAX_PATH_PARTS][KVFS_MAX_NAME_LEN]);

/**
 * @brief Check if a path is absolute or relative.
 *
 * @param path   The path to check
 *
 * @return OK_TRUE if absolute, KO_FALSE otherwise.
 */
bool32_t
kvfs_is_absolute_path(const char *path);

#endif /* ifndef KERNEL_FS_VFS_H_ */
